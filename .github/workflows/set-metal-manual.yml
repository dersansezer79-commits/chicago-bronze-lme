name: Set Metal (Manual)

on:
  workflow_dispatch:
    inputs:
      metal:
        description: "Choose the metal"
        required: true
        type: choice
        options: [aluminum, copper, lead, nickel, zinc, tin]
        default: copper
      price:
        description: "Price (use dot, e.g., 30450.5)"
        required: true
        type: string
      unit:
        description: "Unit of the price you entered"
        required: true
        type: choice
        options: ["USD/kg", "USD/tonne", "USD/ton", "TRY/kg"]
        default: "USD/tonne"
      usdtry:
        description: "USD/TRY rate (only if unit is TRY/kg)"
        required: false
        type: string
      note:
        description: "Optional note (e.g., source/date)"
        required: false
        type: string

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Write updater script
        run: |
          mkdir -p tools
          cat > tools/update_lme_manual.js <<'JS'
          #!/usr/bin/env node
          const fs = require('fs');
          const path = require('path');

          const allowed = ["aluminum","copper","lead","nickel","zinc","tin"];
          const metal = (process.env.INPUT_METAL || "").toLowerCase();
          const priceStr = process.env.INPUT_PRICE || "";
          const unit = process.env.INPUT_UNIT || "USD/tonne";
          const usdtryStr = process.env.INPUT_USDTRY || "";
          const note = process.env.INPUT_NOTE || "";

          if (!allowed.includes(metal)) {
            console.error("Invalid metal:", metal);
            process.exit(1);
          }

          const toFloat = s => {
            if (typeof s !== "string") return NaN;
            return parseFloat(s.replace(",", "."));
          };

          let price = toFloat(priceStr);
          if (!isFinite(price)) {
            console.error("Invalid price:", priceStr);
            process.exit(1);
          }

          const KG_PER_TONNE = 1000;
          const KG_PER_TON_US = 907.18474;

          function toUsdPerKg(p, unit) {
            switch (unit) {
              case "USD/kg":    return p;
              case "USD/tonne": return p / KG_PER_TONNE;
              case "USD/ton":   return p / KG_PER_TON_US; // short ton (US)
              case "TRY/kg": {
                const usdtry = toFloat(usdtryStr);
                if (!isFinite(usdtry) || usdtry <= 0) {
                  console.error("USD/TRY required and must be > 0 for TRY/kg.");
                  process.exit(1);
                }
                return p / usdtry; // TRY/kg -> USD/kg
              }
              default:
                console.error("Unknown unit:", unit);
                process.exit(1);
            }
          }

          const usdPerKg = Math.round(toUsdPerKg(price, unit) * 1e6) / 1e6; // 6 decimals
          const filePath = process.env.LME_JSON_PATH || path.join("lme_automation","lme.json");

          // Ensure directory
          fs.mkdirSync(path.dirname(filePath), { recursive: true });

          // Load or create baseline
          let data;
          if (fs.existsSync(filePath)) {
            data = JSON.parse(fs.readFileSync(filePath, "utf8"));
          } else {
            data = {
              timestamp: new Date().toISOString(),
              usd_per_kg: { aluminum:0, copper:0, lead:0, nickel:0, zinc:0, tin:0 },
              benchmarks: { wsj_usa_copper_lb: null, wsj_usa_copper_kg: null },
              meta: {
                sources_used: {
                  aluminum:"unknown", copper:"unknown", lead:"unknown",
                  nickel:"unknown", zinc:"unknown", tin:"unknown",
                  wsj_usa_copper:"unknown"
                },
                usdtry: null,
                notes: ""
              }
            };
          }

          // Update fields
          if (!data.usd_per_kg) data.usd_per_kg = {};
          data.usd_per_kg[metal] = usdPerKg;

          if (!data.meta) data.meta = {};
          if (!data.meta.sources_used) data.meta.sources_used = {};
          data.meta.sources_used[metal] = `manual@GitHubActions (${unit})`;

          if (unit === "TRY/kg") {
            const u = toFloat(usdtryStr);
            if (isFinite(u) && u > 0) data.meta.usdtry = u;
          }

          const stamp = new Date().toISOString();
          data.timestamp = stamp;

          const noteLine = note ? `[${stamp}] ${metal}=${usdPerKg} USD/kg :: ${note}` : `[${stamp}] ${metal}=${usdPerKg} USD/kg`;
          data.meta.notes = (data.meta.notes ? data.meta.notes + " | " : "") + noteLine;

          fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
          console.log("Updated", filePath, "=>", metal, usdPerKg, "USD/kg");
          JS

          chmod +x tools/update_lme_manual.js

      - name: Update lme.json
        env:
          INPUT_METAL: ${{ github.event.inputs.metal }}
          INPUT_PRICE: ${{ github.event.inputs.price }}
          INPUT_UNIT:  ${{ github.event.inputs.unit }}
          INPUT_USDTRY: ${{ github.event.inputs.usdtry }}
          INPUT_NOTE: ${{ github.event.inputs.note }}
          LME_JSON_PATH: lme_automation/lme.json
        run: node tools/update_lme_manual.js

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: >
            chore: manual set ${{ github.event.inputs.metal }}
            to ${{ github.event.inputs.price }} (${{
              github.event.inputs.unit
            }}) by ${{ github.actor }}
          file_pattern: |
            lme_automation/lme.json
            tools/update_lme_manual.js
